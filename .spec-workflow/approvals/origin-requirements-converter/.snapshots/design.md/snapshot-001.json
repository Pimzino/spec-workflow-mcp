{
  "id": "snapshot_1760596205387_n2oli9jhs",
  "approvalId": "approval_1760596205386_pgoigyq2a",
  "approvalTitle": "设计文档审批 - 原始需求文档转换器",
  "version": 1,
  "timestamp": "2025-10-16T06:30:05.387Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# 设计文档 - 原始需求文档转换器\n\n## 概述\n\n原始需求文档转换器是一个基于 Pandoc 的文档处理系统，为 spec-workflow-mcp 项目提供多格式文档转换能力。该系统支持 Word 到 Markdown（word2md）和 Markdown 到 Word（md2word）双向转换，并能将原始需求文档自动转换为符合 spec-workflow 规范的需求文档。\n\n**核心特性：**\n- 双向文档转换（Word ↔ Markdown）\n- 策略模式架构，便于扩展其他格式\n- 多级降级方案（本地 Pandoc → API 服务）\n- 完整的临时文件管理\n- 与现有 spec-workflow 流程无缝集成\n\n## 技术标准对齐\n\n### 技术标准 (tech.md)\n\n本设计遵循以下技术标准：\n\n- **TypeScript 开发**：使用 TypeScript 实现类型安全\n- **MCP 协议**：遵循 MCP SDK 规范实现工具\n- **模块化设计**：采用单一职责原则，每个模块职责清晰\n- **错误处理**：统一的错误处理和日志记录机制\n- **异步编程**：使用 async/await 处理异步操作\n\n### 项目结构 (structure.md)\n\n实现将遵循项目组织规范：\n\n```\nsrc/\n├── tools/                        # MCP 工具定义\n│   ├── convert-origin-requirement.ts  # 原始需求转换工具\n│   └── md2word.ts                     # Markdown 转 Word 工具\n├── services/                     # 业务服务层\n│   ├── document-converter.ts          # 文档转换服务\n│   ├── strategies/                    # 转换策略实现\n│   │   ├── conversion-strategy.ts     # 策略接口\n│   │   ├── word2md-strategy.ts        # Word 转 MD 策略\n│   │   └── md2word-strategy.ts        # MD 转 Word 策略\n│   └── pandoc-executor.ts             # Pandoc 命令执行器\n├── utils/                        # 工具函数\n│   ├── file-utils.ts                  # 文件操作工具\n│   └── path-utils.ts                  # 路径处理工具\n└── types/                        # 类型定义\n    └── converter-types.ts             # 转换器类型定义\n```\n\n## 代码复用分析\n\n### 现有组件复用\n\n- **ConfigManager** (`src/utils/config.ts`)：复用配置管理逻辑，读取 `pandocPath` 和 `converterApiUrl`\n- **Logger** (`src/utils/logger.ts`)：复用日志记录机制，统一错误和调试信息输出\n- **FileSystem Utils**：复用现有的文件操作工具（如果存在）\n- **MCP Tool Registration**：复用现有的 MCP 工具注册机制\n\n### 集成点\n\n- **MCP Server** (`src/index.ts`)：注册新的 MCP tools\n- **Config System** (`.spec-workflow/config.toml`)：扩展配置项以支持 Pandoc 和 API 配置\n- **Dashboard**：集成转换状态显示（可选，未来扩展）\n\n## 架构设计\n\n### 整体架构\n\n系统采用**策略模式 + 服务层**架构，实现高内聚低耦合：\n\n```mermaid\ngraph TD\n    A[MCP Tools] --> B[DocumentConverter Service]\n    B --> C[Strategy Interface]\n    C --> D[Word2MdStrategy]\n    C --> E[Md2WordStrategy]\n    D --> F[PandocExecutor]\n    E --> F\n    F --> G[Local Pandoc]\n    F --> H[API Service]\n    B --> I[FileUtils]\n    B --> J[ConfigManager]\n```\n\n### 模块化设计原则\n\n1. **单一职责**：每个类/模块负责一个明确的功能\n   - `DocumentConverter`：协调转换流程\n   - `Strategy`：实现具体转换逻辑\n   - `PandocExecutor`：执行 Pandoc 命令\n\n2. **依赖倒置**：高层模块不依赖低层模块，都依赖抽象\n   - 通过 `IConversionStrategy` 接口解耦\n\n3. **开闭原则**：对扩展开放，对修改关闭\n   - 新增转换类型只需添加新策略，无需修改现有代码\n\n## 组件和接口\n\n### 1. MCP Tool: convert-origin-requirement\n\n**目的：** 将原始需求文档转换为符合 spec-workflow 规范的需求文档\n\n**接口：**\n```typescript\ninterface ConvertOriginRequirementInput {\n  filename: string;           // 原始文件名（支持 #前缀）\n  specName?: string;          // 目标 spec 名称（可选，自动生成）\n  outputPath?: string;        // 自定义输出路径（可选）\n}\n\ninterface ConvertOriginRequirementResult {\n  success: boolean;\n  outputPath: string;         // 生成的需求文档路径\n  tempPath?: string;          // 临时文件路径（如有转换）\n  message: string;\n  summary?: {\n    title: string;\n    sectionsCount: number;\n  };\n}\n```\n\n**依赖：**\n- `DocumentConverter`（文档转换服务）\n- `ConfigManager`（配置管理）\n- `FileUtils`（文件操作）\n\n**处理流程：**\n1. 解析 `filename`（去除 `#` 前缀）\n2. 在 `origin-requirements/` 查找文件\n3. 根据扩展名判断是否需要转换\n4. 调用 `DocumentConverter` 进行转换（如需）\n5. 读取 Markdown 内容\n6. 转换为 spec-workflow 规范格式\n7. 保存到 `.spec-workflow/specs/{spec-name}/requirements.md`\n\n### 2. MCP Tool: md2word\n\n**目的：** 将 Markdown 文件转换为 Word 文档\n\n**接口：**\n```typescript\ninterface Md2WordInput {\n  filePath: string;           // Markdown 文件完整路径\n  outputPath?: string;        // 自定义输出路径（可选）\n}\n\ninterface Md2WordResult {\n  success: boolean;\n  outputPath: string;         // 生成的 Word 文档路径\n  message: string;\n}\n```\n\n**依赖：**\n- `DocumentConverter`（文档转换服务）\n- `Md2WordStrategy`（转换策略）\n\n**处理流程：**\n1. 验证输入文件存在且为 `.md` 格式\n2. 确定输出路径（默认为同级目录）\n3. 调用 `DocumentConverter.convert('md2word', ...)`\n4. 返回生成的 Word 文件路径\n\n### 3. Service: DocumentConverter\n\n**目的：** 文档转换服务的协调者，管理转换策略和配置\n\n**接口：**\n```typescript\nclass DocumentConverter {\n  constructor(config: ConverterConfig);\n  \n  async convert(\n    type: 'word2md' | 'md2word',\n    inputPath: string,\n    outputPath: string,\n    options?: ConversionOptions\n  ): Promise<ConversionResult>;\n  \n  private getStrategy(type: string): IConversionStrategy;\n  private shouldUsePandoc(): Promise<boolean>;\n}\n\ninterface ConverterConfig {\n  pandocPath?: string;        // Pandoc 路径\n  converterApiUrl?: string;   // API 服务地址\n  tempDir: string;            // 临时文件目录\n}\n\ninterface ConversionResult {\n  success: boolean;\n  outputPath: string;\n  tempFiles?: string[];       // 临时文件列表\n  error?: Error;\n}\n```\n\n**依赖：**\n- `IConversionStrategy`（策略接口）\n- `PandocExecutor`（Pandoc 执行器）\n- `ConfigManager`（配置管理）\n\n**核心逻辑：**\n```typescript\nasync convert(type, inputPath, outputPath, options) {\n  // 1. 选择策略\n  const strategy = this.getStrategy(type);\n  \n  // 2. 判断使用本地 Pandoc 还是 API\n  const usePandoc = await this.shouldUsePandoc();\n  \n  // 3. 执行转换\n  if (usePandoc) {\n    return await strategy.convertWithPandoc(inputPath, outputPath);\n  } else {\n    return await strategy.convertWithApi(inputPath, outputPath, this.config.converterApiUrl);\n  }\n}\n```\n\n### 4. Strategy Interface: IConversionStrategy\n\n**目的：** 定义转换策略的统一接口\n\n**接口：**\n```typescript\ninterface IConversionStrategy {\n  convertWithPandoc(\n    inputPath: string,\n    outputPath: string,\n    options?: PandocOptions\n  ): Promise<ConversionResult>;\n  \n  convertWithApi(\n    inputPath: string,\n    outputPath: string,\n    apiUrl: string\n  ): Promise<ConversionResult>;\n}\n\ninterface PandocOptions {\n  extractMedia?: string;      // 媒体提取目录\n  format?: string;            // 输入格式（docx/gfm）\n  outputFormat?: string;      // 输出格式（gfm/docx）\n  wrapMode?: 'none' | 'auto'; // 文本换行模式\n}\n```\n\n### 5. Strategy Implementation: Word2MdStrategy\n\n**目的：** 实现 Word 到 Markdown 的转换逻辑\n\n**Pandoc 命令构建：**\n```typescript\nclass Word2MdStrategy implements IConversionStrategy {\n  async convertWithPandoc(inputPath: string, outputPath: string): Promise<ConversionResult> {\n    const filename = path.basename(inputPath, path.extname(inputPath));\n    const outputDir = path.join(path.dirname(inputPath), '.temp', filename);\n    \n    // 创建输出目录\n    await fs.mkdir(outputDir, { recursive: true });\n    \n    // 构建命令\n    const cmd = [\n      this.pandocPath,\n      inputPath,\n      '-f', 'docx',\n      '-t', 'gfm',\n      '--extract-media', path.join(outputDir, 'media'),\n      '--wrap=none',\n      '-o', path.join(outputDir, `${filename}.md`)\n    ];\n    \n    // 执行转换\n    await this.executor.execute(cmd);\n    \n    return {\n      success: true,\n      outputPath: path.join(outputDir, `${filename}.md`),\n      tempFiles: [outputDir]\n    };\n  }\n  \n  async convertWithApi(inputPath: string, outputPath: string, apiUrl: string): Promise<ConversionResult> {\n    const filename = path.basename(inputPath, path.extname(inputPath));\n    const outputDir = path.join(path.dirname(inputPath), '.temp', filename);\n    \n    // 发送文件到 API\n    const formData = new FormData();\n    formData.append('file', await fs.readFile(inputPath));\n    formData.append('type', 'word2md');\n    \n    const response = await fetch(apiUrl, {\n      method: 'POST',\n      body: formData\n    });\n    \n    if (!response.ok) {\n      throw new Error(`API request failed: ${response.status}`);\n    }\n    \n    // 接收压缩包并解压\n    const zipBuffer = await response.arrayBuffer();\n    await this.extractZip(zipBuffer, outputDir);\n    \n    return {\n      success: true,\n      outputPath: path.join(outputDir, `${filename}.md`),\n      tempFiles: [outputDir]\n    };\n  }\n}\n```\n\n### 6. Strategy Implementation: Md2WordStrategy\n\n**目的：** 实现 Markdown 到 Word 的转换逻辑\n\n**Pandoc 命令构建：**\n```typescript\nclass Md2WordStrategy implements IConversionStrategy {\n  async convertWithPandoc(inputPath: string, outputPath?: string): Promise<ConversionResult> {\n    const inputDir = path.dirname(inputPath);\n    const filename = path.basename(inputPath, '.md');\n    const output = outputPath || path.join(inputDir, `${filename}.docx`);\n    \n    // 构建命令\n    const cmd = [\n      this.pandocPath,\n      inputPath,\n      '-f', 'gfm',\n      '-t', 'docx',\n      '-o', output\n    ];\n    \n    // 执行转换\n    await this.executor.execute(cmd);\n    \n    return {\n      success: true,\n      outputPath: output\n    };\n  }\n  \n  async convertWithApi(inputPath: string, outputPath: string, apiUrl: string): Promise<ConversionResult> {\n    const inputDir = path.dirname(inputPath);\n    const filename = path.basename(inputPath, '.md');\n    const output = outputPath || path.join(inputDir, `${filename}.docx`);\n    \n    // 发送文件到 API\n    const formData = new FormData();\n    formData.append('file', await fs.readFile(inputPath));\n    formData.append('type', 'md2word');\n    \n    const response = await fetch(apiUrl, {\n      method: 'POST',\n      body: formData\n    });\n    \n    if (!response.ok) {\n      throw new Error(`API request failed: ${response.status}`);\n    }\n    \n    // 接收文件流并保存\n    const buffer = await response.arrayBuffer();\n    await fs.writeFile(output, Buffer.from(buffer));\n    \n    return {\n      success: true,\n      outputPath: output\n    };\n  }\n}\n```\n\n### 7. Utility: PandocExecutor\n\n**目的：** 执行 Pandoc 命令并处理结果\n\n**接口：**\n```typescript\nclass PandocExecutor {\n  constructor(private pandocPath: string);\n  \n  async checkAvailability(): Promise<boolean>;\n  async execute(args: string[]): Promise<ExecutionResult>;\n  private handleError(error: any): never;\n}\n\ninterface ExecutionResult {\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n}\n```\n\n**实现：**\n```typescript\nclass PandocExecutor {\n  async checkAvailability(): Promise<boolean> {\n    try {\n      const result = await this.execute(['--version']);\n      return result.exitCode === 0;\n    } catch {\n      return false;\n    }\n  }\n  \n  async execute(args: string[]): Promise<ExecutionResult> {\n    return new Promise((resolve, reject) => {\n      const process = spawn(this.pandocPath, args);\n      \n      let stdout = '';\n      let stderr = '';\n      \n      process.stdout.on('data', (data) => { stdout += data; });\n      process.stderr.on('data', (data) => { stderr += data; });\n      \n      process.on('close', (code) => {\n        if (code === 0) {\n          resolve({ stdout, stderr, exitCode: code });\n        } else {\n          reject(new Error(`Pandoc failed: ${stderr}`));\n        }\n      });\n    });\n  }\n}\n```\n\n## 数据模型\n\n### ConversionConfig\n\n```typescript\ninterface ConversionConfig {\n  // Pandoc 配置\n  pandocPath?: string;                // Pandoc 可执行文件路径\n  \n  // API 配置\n  converterApiUrl?: string;           // 转换 API 服务地址\n  apiTimeout?: number;                // API 超时时间（默认 30000ms）\n  \n  // 路径配置\n  originRequirementsDir: string;      // 原始需求目录\n  tempDir: string;                    // 临时文件目录\n  \n  // 其他配置\n  verbose?: boolean;                  // 详细日志模式\n}\n```\n\n### ConversionTask\n\n```typescript\ninterface ConversionTask {\n  id: string;                         // 任务 ID\n  type: 'word2md' | 'md2word';        // 转换类型\n  inputPath: string;                  // 输入文件路径\n  outputPath: string;                 // 输出文件路径\n  status: 'pending' | 'running' | 'completed' | 'failed';\n  createdAt: Date;\n  completedAt?: Date;\n  error?: Error;\n}\n```\n\n### PandocCommand\n\n```typescript\ninterface PandocCommand {\n  executable: string;                 // Pandoc 可执行文件路径\n  args: string[];                     // 命令参数\n  workingDir?: string;                // 工作目录\n}\n```\n\n## 配置管理\n\n### 配置优先级\n\n系统按以下优先级读取 Pandoc 路径配置：\n\n1. **命令行参数** `--pandocPath`（最高）\n2. **配置文件** `.spec-workflow/config.toml` 中的 `pandocPath`\n3. **系统 PATH** 中的 `pandoc` 命令\n4. **API 服务** `converterApiUrl`（降级方案）\n\n### 配置文件示例\n\n```toml\n# .spec-workflow/config.toml\n\n# Pandoc 可执行文件路径（可选）\npandocPath = \"/usr/local/bin/pandoc\"\n\n# 文档转换 API 服务地址（降级方案）\nconverterApiUrl = \"https://converter-api.example.com/convert\"\n\n# API 请求超时时间（毫秒）\napiTimeout = 30000\n\n# 临时文件目录（相对于项目根目录）\ntempDir = \"origin-requirements/.temp\"\n```\n\n### 配置加载逻辑\n\n```typescript\nclass ConfigLoader {\n  static async loadConfig(cliArgs: CliArgs): Promise<ConversionConfig> {\n    // 1. 从命令行参数读取\n    if (cliArgs.pandocPath) {\n      return { pandocPath: cliArgs.pandocPath, ...defaultConfig };\n    }\n    \n    // 2. 从配置文件读取\n    const fileConfig = await this.loadConfigFile();\n    if (fileConfig.pandocPath) {\n      return { ...defaultConfig, ...fileConfig };\n    }\n    \n    // 3. 尝试系统 PATH\n    const systemPandoc = await this.findInSystemPath('pandoc');\n    if (systemPandoc) {\n      return { pandocPath: systemPandoc, ...defaultConfig };\n    }\n    \n    // 4. 使用 API 服务\n    return { ...defaultConfig, ...fileConfig };\n  }\n}\n```\n\n## 错误处理\n\n### 错误场景\n\n#### 1. 文件不存在错误\n\n```typescript\nclass FileNotFoundError extends Error {\n  constructor(filePath: string) {\n    super(`File not found: ${filePath}`);\n    this.name = 'FileNotFoundError';\n  }\n}\n```\n\n**处理：** 返回友好提示，指明文件路径\n\n**用户影响：** 看到明确的错误提示和建议\n\n#### 2. Pandoc 不可用错误\n\n```typescript\nclass PandocUnavailableError extends Error {\n  constructor() {\n    super('Pandoc is not available. Please install Pandoc or configure converterApiUrl.');\n    this.name = 'PandocUnavailableError';\n  }\n}\n```\n\n**处理：** 自动降级到 API 服务\n\n**用户影响：** 系统自动切换，用户无感知（除非 API 也不可用）\n\n#### 3. 转换失败错误\n\n```typescript\nclass ConversionError extends Error {\n  constructor(\n    public type: 'word2md' | 'md2word',\n    public inputPath: string,\n    public cause: Error\n  ) {\n    super(`Conversion failed: ${cause.message}`);\n    this.name = 'ConversionError';\n  }\n}\n```\n\n**处理：** 记录详细日志，返回错误信息\n\n**用户影响：** 看到具体失败原因和建议\n\n#### 4. API 服务错误\n\n```typescript\nclass ApiServiceError extends Error {\n  constructor(\n    public statusCode: number,\n    public responseBody: string\n  ) {\n    super(`API service error (${statusCode}): ${responseBody}`);\n    this.name = 'ApiServiceError';\n  }\n}\n```\n\n**处理：** 重试机制（最多 3 次），失败后返回错误\n\n**用户影响：** 看到网络错误提示和建议\n\n#### 5. 解压缩失败错误\n\n```typescript\nclass ExtractionError extends Error {\n  constructor(zipPath: string, cause: Error) {\n    super(`Failed to extract zip file: ${zipPath}. ${cause.message}`);\n    this.name = 'ExtractionError';\n  }\n}\n```\n\n**处理：** 删除损坏的临时文件，返回错误\n\n**用户影响：** 看到解压失败提示\n\n### 统一错误处理\n\n```typescript\nclass ErrorHandler {\n  static handle(error: Error, context: string): never {\n    // 记录错误日志\n    logger.error(`[${context}] ${error.name}: ${error.message}`, {\n      stack: error.stack,\n      context\n    });\n    \n    // 根据错误类型返回不同提示\n    if (error instanceof FileNotFoundError) {\n      throw new Error(`未找到文件 '${error.filePath}'，请检查文件路径`);\n    }\n    \n    if (error instanceof PandocUnavailableError) {\n      throw new Error('本地 Pandoc 不可用，正在降级到 API 服务...');\n    }\n    \n    if (error instanceof ApiServiceError) {\n      throw new Error(\n        `API 转换服务不可用（HTTP ${error.statusCode}），` +\n        `请检查网络连接或配置 pandocPath 参数`\n      );\n    }\n    \n    // 默认错误处理\n    throw error;\n  }\n}\n```\n\n## 测试策略\n\n### 单元测试\n\n**目标：** 覆盖核心转换逻辑和边界条件\n\n**测试用例：**\n\n1. **PandocExecutor 测试**\n   ```typescript\n   describe('PandocExecutor', () => {\n     it('should check pandoc availability', async () => {\n       const executor = new PandocExecutor('/usr/local/bin/pandoc');\n       const available = await executor.checkAvailability();\n       expect(available).toBe(true);\n     });\n     \n     it('should execute pandoc command', async () => {\n       const executor = new PandocExecutor('pandoc');\n       const result = await executor.execute(['--version']);\n       expect(result.exitCode).toBe(0);\n     });\n   });\n   ```\n\n2. **Word2MdStrategy 测试**\n   ```typescript\n   describe('Word2MdStrategy', () => {\n     it('should convert Word to Markdown with Pandoc', async () => {\n       const strategy = new Word2MdStrategy(mockExecutor);\n       const result = await strategy.convertWithPandoc(\n         'test.docx',\n         '.temp/test/'\n       );\n       expect(result.success).toBe(true);\n       expect(fs.existsSync(result.outputPath)).toBe(true);\n     });\n     \n     it('should handle Pandoc failure gracefully', async () => {\n       const strategy = new Word2MdStrategy(failingExecutor);\n       await expect(\n         strategy.convertWithPandoc('test.docx', '.temp/test/')\n       ).rejects.toThrow(ConversionError);\n     });\n   });\n   ```\n\n3. **Md2WordStrategy 测试**\n   ```typescript\n   describe('Md2WordStrategy', () => {\n     it('should convert Markdown to Word', async () => {\n       const strategy = new Md2WordStrategy(mockExecutor);\n       const result = await strategy.convertWithPandoc(\n         'test.md',\n         'test.docx'\n       );\n       expect(result.success).toBe(true);\n       expect(fs.existsSync('test.docx')).toBe(true);\n     });\n   });\n   ```\n\n4. **ConfigLoader 测试**\n   ```typescript\n   describe('ConfigLoader', () => {\n     it('should prioritize CLI args over config file', async () => {\n       const config = await ConfigLoader.loadConfig({\n         pandocPath: '/custom/pandoc'\n       });\n       expect(config.pandocPath).toBe('/custom/pandoc');\n     });\n     \n     it('should fall back to API when Pandoc unavailable', async () => {\n       const config = await ConfigLoader.loadConfig({});\n       expect(config.converterApiUrl).toBeDefined();\n     });\n   });\n   ```\n\n### 集成测试\n\n**目标：** 测试完整的转换流程\n\n**测试场景：**\n\n1. **Word 转 Markdown 完整流程**\n   ```typescript\n   it('should convert Word document to spec-workflow requirements', async () => {\n     // 准备测试文件\n     const testDocx = 'test-fixtures/sample.docx';\n     \n     // 执行转换\n     const result = await convertOriginRequirement({\n       filename: '#sample.docx',\n       specName: 'test-spec'\n     });\n     \n     // 验证结果\n     expect(result.success).toBe(true);\n     expect(fs.existsSync(result.outputPath)).toBe(true);\n     \n     // 验证临时文件\n     const tempDir = 'origin-requirements/.temp/sample';\n     expect(fs.existsSync(tempDir)).toBe(true);\n     expect(fs.existsSync(`${tempDir}/sample.md`)).toBe(true);\n   });\n   ```\n\n2. **Markdown 转 Word 流程**\n   ```typescript\n   it('should convert Markdown to Word document', async () => {\n     const testMd = 'test-fixtures/sample.md';\n     \n     const result = await md2word({\n       filePath: testMd\n     });\n     \n     expect(result.success).toBe(true);\n     expect(fs.existsSync(result.outputPath)).toBe(true);\n     expect(result.outputPath).toMatch(/\\.docx$/);\n   });\n   ```\n\n3. **Pandoc 降级到 API 流程**\n   ```typescript\n   it('should fall back to API when Pandoc unavailable', async () => {\n     // 模拟 Pandoc 不可用\n     mockPandocExecutor.checkAvailability.mockResolvedValue(false);\n     \n     // 执行转换\n     const result = await convertOriginRequirement({\n       filename: '#sample.docx'\n     });\n     \n     // 验证使用了 API\n     expect(mockApiClient.convert).toHaveBeenCalled();\n     expect(result.success).toBe(true);\n   });\n   ```\n\n### 端到端测试\n\n**目标：** 模拟真实用户场景\n\n**测试场景：**\n\n1. **完整的需求文档生成流程**\n   ```typescript\n   it('E2E: Create spec from Word document', async () => {\n     // 1. 准备 Word 文档\n     const docxPath = 'origin-requirements/feature-request.docx';\n     await fs.copyFile('test-fixtures/sample.docx', docxPath);\n     \n     // 2. 通过 MCP 工具转换\n     const result = await mcpServer.callTool('convert-origin-requirement', {\n       filename: '#feature-request.docx',\n       specName: 'my-feature'\n     });\n     \n     // 3. 验证生成的需求文档\n     const requirementsPath = '.spec-workflow/specs/my-feature/requirements.md';\n     expect(fs.existsSync(requirementsPath)).toBe(true);\n     \n     // 4. 验证内容格式\n     const content = await fs.readFile(requirementsPath, 'utf-8');\n     expect(content).toMatch(/# 需求文档/);\n     expect(content).toMatch(/## 介绍/);\n   });\n   ```\n\n2. **双向转换场景**\n   ```typescript\n   it('E2E: Word -> Markdown -> Word conversion', async () => {\n     // 1. Word 转 Markdown\n     const word2mdResult = await convertOriginRequirement({\n       filename: '#original.docx'\n     });\n     \n     // 2. Markdown 转 Word\n     const md2wordResult = await md2word({\n       filePath: word2mdResult.tempPath\n     });\n     \n     // 3. 验证两个 Word 文档内容相似\n     expect(fs.existsSync(md2wordResult.outputPath)).toBe(true);\n   });\n   ```\n\n### 测试覆盖目标\n\n- **单元测试覆盖率**：>= 80%\n- **集成测试覆盖**：核心转换流程 100%\n- **E2E 测试覆盖**：主要用户场景 100%\n\n## 性能考虑\n\n### 性能目标\n\n- 单个文档转换时间：< 5 秒（本地 Pandoc）\n- API 转换超时：30 秒\n- 并发转换支持：最多 5 个任务同时进行\n\n### 优化策略\n\n1. **缓存机制**：相同文件的转换结果缓存在 `.temp/` 目录\n2. **并发控制**：使用队列管理多个转换任务\n3. **流式处理**：大文件使用流式读写，避免内存溢出\n4. **增量转换**：检测文件变更，只转换修改过的文件\n\n## 安全性考虑\n\n### 安全措施\n\n1. **路径遍历防护**：验证所有文件路径，禁止 `../` 等危险路径\n2. **文件大小限制**：上传到 API 的文件限制为 10MB\n3. **HTTPS 强制**：API 调用必须使用 HTTPS\n4. **敏感信息保护**：日志中不记录文件完整内容\n5. **命令注入防护**：Pandoc 命令参数严格校验\n\n### 实现示例\n\n```typescript\nclass SecurityValidator {\n  static validatePath(filePath: string, baseDir: string): void {\n    const resolved = path.resolve(baseDir, filePath);\n    if (!resolved.startsWith(baseDir)) {\n      throw new Error('Path traversal detected');\n    }\n  }\n  \n  static validateFileSize(filePath: string, maxSize: number = 10 * 1024 * 1024): void {\n    const stats = fs.statSync(filePath);\n    if (stats.size > maxSize) {\n      throw new Error(`File size exceeds limit: ${maxSize} bytes`);\n    }\n  }\n  \n  static sanitizeCommand(args: string[]): string[] {\n    // 移除危险字符\n    return args.map(arg => \n      arg.replace(/[;&|`$()]/g, '')\n    );\n  }\n}\n```\n\n## 部署考虑\n\n### Docker 支持\n\nDockerfile 中需要安装 Pandoc：\n\n```dockerfile\nFROM node:20-alpine\n\n# 安装 Pandoc\nRUN apk add --no-cache pandoc\n\n# 验证安装\nRUN pandoc --version\n\n# ... 其他构建步骤\n```\n\n### 环境要求\n\n- Node.js >= 20.x\n- Pandoc >= 2.19（可选，有 API 降级）\n- 磁盘空间：至少 100MB 用于临时文件\n\n## 未来扩展\n\n### 预留接口\n\n1. **Excel2MdStrategy**：支持 Excel 转 Markdown\n2. **Pdf2MdStrategy**：支持 PDF 转 Markdown\n3. **Html2MdStrategy**：支持 HTML 转 Markdown\n\n### 架构扩展点\n\n- 策略注册机制：动态加载转换策略\n- 插件系统：支持第三方转换器\n- 转换流水线：支持多步骤转换（如 PDF → Word → Markdown）\n\n",
  "fileStats": {
    "size": 25712,
    "lines": 939,
    "lastModified": "2025-10-16T06:29:57.378Z"
  },
  "comments": []
}